---
title: "Exercises"
linktitle: "5. Functions"
date: "2020-08-10"
publishdate: "2020-08-10"
menu:
  exercise:
type: docs
output:
  blogdown::html_page:
    toc: true
    toc_depth: 2
    number_sections: true
    pandoc_args: ["--number-offset=4"]
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  error = TRUE,
  collapse = TRUE,
  comment = "#> ",
  class.output = "output",
  class.message = "message",
  class.error = "message"
)
```
# Functions

## Write a function to calculate exponents

### Square a number {-}

You're tired of writing `x^2` when you want to square `x`. Make a function to square a number. You can call it `square()`.

```{r, eval = FALSE}
# start out with a number to test
x <- 3
# you'll want your function to return this number
x^2
square <- function() {
  
}
# test it out
square(x)
square(53)
53^2 # does this match?
```

### Raise to any power {-}

You don't just want to square numbers, you want to raise them to higher powers too. Make a function that uses two arguments, `x` for a number, and `power` for the power. Call it `raise()`.

```{r, eval = FALSE}
raise <- function() {
  
}

# test with
raise(x = 2, power = 4)
# should give you
2^4
```

### Exercise {-}

Change your `raise()` function to default to squaring `x` when the user doesn't enter a value for `power`.

```{r}

# test
raise(x = 5)
# should give you
5^2
```

## Change the grouping variable when summarizing


### Grouping argument {-}

Write a function to calculate the stratified mean income for grouping variable `var`. In other words, write a function such that `mean_group_inc(var = "sex")` produces the same results as the first line on the previous slide, `mean_group_inc(var = "race_eth")` the second.

```{r}
mean_group_inc <- function(var) {
  
}

# test with
mean_group_inc(var = "race_eth")
```

### Grouping and summarizing arguments {-}

Rewrite your function to accept two arguments: `group_var` to determine what the grouping variable is, and `mean_var` to determine what variable you want to take the mean of (e.g., `mean_group(group_var = "sex", mean_var = "income")` should give you the same results as above).

```{r}
mean_group <- function(group_var, mean_var) {
  
}

# test with
mean_group(group_var = "sex", mean_var = "income")
```

## For loops

### Exercise {-}

Change the last for loop in the slides to loop over different variables instead of different quantiles. That is, calculate the 0.25 quantile for each of `c("income", "age_bir", "nsibs")` in a for loop.

```{r}

```


### Exercise {-}

You can nest for loops inside each other, as long as you use different iteration variables. Write a nested for loop to iterate over variables (with `i`) and quantiles (with `j`). You'll need to start with an empty matrix instead of a vector, with rows indexed by `i` and columns by `j`. Calculate each of the deciles for each of the above variables.

```{r}

```

## Challenge

Create a function that calculates the stratified proportion of people with different levels of `eyesight` by any categorical variable. Then use any technique (besides copying and pasting) to calculate the proportions stratified by `sex`, `race_eth`, and `region`. You should end up with something like this:

```{r, echo = FALSE, eval = FALSE}
eye_func <- function(var) {
  nlsy %>%
  rename(var_level = var) %>%
  group_by(var_level, eyesight) %>%
  summarize(n = n()) %>%
  mutate(prop = n / sum(n),
         var = var) %>%
  ungroup() %>%
    select(var, everything())
}
print(map_dfr(c("sex", "race_eth", "region"), eye_func), n = 45)
```